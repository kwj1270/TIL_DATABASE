SQL 고급
=======================
# 1. MySQL 데이터 형식
## 1.1. MySQL에서 지원하는 데이터 형식의 종류
### 1.1.1. 숫자 데이터 형식
``` 
    BIT                              1~64bit 표현. b'0000'형식                          N/8 
★  TINYINT                          정수 -128 ~ 128`                                    1
★  SMALLINT                         정수 약 -32768 ~ 32767                              2
    MEDIUMINT                        정수 약 -8388608 ~ 8388607                          3
★  INT/INTEGER                      정수 약 -21억 ~ 21억                                 4
★  BIGINT                           정수 약 -900경 ~ +900경                              8
★  FLOAT                            소수점 아래 7자리까지 표현                            4
★  DOUBLE/REAL                      소수점 아래 15자리까지 표현                           8
★  DECIMAL(m.[d])/NUMERIC(m.[d])    전체 자리수(m)와 소수점 이하 자릿수(d)표기            5~17
```
```FLOAT``` 과 ```DOUBLE```은 정확한 값이 아닌 **근사치**의 숫자를 저장하지만 상당히 큰 숫자를 저장할 수 있다.      
그래도 만약 실수를 사용하려면 정확한 값을 계산하는 ```DECIMAL(m.[d])```을 사용하자         
        
정수는 음수와 양수를 나타낼 수 있다.        
만약 음수를 나타내고자 하지 않다면 **UNSIGNED** 키워드를 앞에 붙여서 ```0 ~ 양수 2배 값``` 까지 사용할 수 있다.      
실수 데이터형에도 사용할 수는 있지만 잘 사용하지는 않는다.     
    
### 1.1.2. 문자 데이터 형식
```
★  CAHR(n)                          고정길이 문자형, n을 사용하면 1 ~ 255까지 지정       1~255
★  VARCHAR(n)                       가변길이 문자형, n을 사용하면 1 ~ 65535까지 지정     1~65535
    BINARY(n)                        고정길이의 이진 데이터 값                           1~255
    VARBINARY(n)                     가변길이의 이진 데이터 값                           1~255    
    
    TINYTEXT                         255 크기의 TEXT 데이터 값                           1~255
    TEXT                             N 크기의 TEXT 데이터 값                             1~65535
    MEDIUMTEXT                       16777215 크기의 TEXT 데이터 값                      1~16777215
★  LONGTEXT                         최대 4GB 크기의 TEXT 데이터 값                      1~4294967295

    TINYBLOB                         255 크기의 BLOB 데이터 값                           1~255
    BLOB                             N 크기의 BLOB 데이터 값                             1~65535
    MEDIUMBLOB                       16777215 크기의 BLOB 데이터 값                      1~16777215
★  LONGBLOB                         최대 4GB 크기의 BLOB 데이터 값                      1~4294967295

    ENUM(값들...)                     최대 65535개의 열거형 데이터 값                     1 또는 2
    SET(값들...)                      최대 64개의 서로 다른 데이터 값                     1,2,3,4,8
```
```CHAR(n)```는 고정길이 문자형으로 자릿수가 고정되어 있다.      
반면에 ```VARCHAR(n)```는 가변길이 문자형으로 자릿수가 변동된다.       
      
예를 들면 ```n``` 이 ```10```이라는 가정하에 'ABC'를 넣으면      
```CHAR(10)```는 'ABC'를 저장하고 남은 7자리는 비워두고     
```VARCHAR(10)```는 'ABC'를 저장한 크기로 변한다 즉, 3자리가 된다.     
    
```VARCHAR(n)```는 공간을 효율적으로 운영할 수 있다.    
하지만 ```INSERT/UPDATE```시 ```CHAR(n)```가 더 좋은 성능을 발휘한다.  
      
참고로 MySQL에서는 한글과 영문 구분없이 자릿수를 표현한다.     
즉 n이 3이면 '가나다' 와 'abc' 이렇게 구분없이 사용 가능하다.    
하지만 그렇다고 바이트까지 같다는 얘기는 아니다.   
일반적으로 한글의 바이트는 영어으 바이트의 3배이다.   
  
```BINARY```류의 데이터형은 이진 데이터 값을 저장하는데 사용한다.    
    
```TEXT``` 형식은 대용량의 글자를 저장하기 위한 형식이다.   
      
```BLOB``` 형식은 대용량의 이진데이터를 저장하는데 사용할 수 있다.      
즉, 사진 파일, 동영상 파일, 문서 파일등을 저장할 수 있게 해준다.     
    
```ENUM```은 열거형 데이터를 슬 때 사용될 수 있는데 예로 요일(7개)을 ```ENUM``` 형식으로 설정할 수 있다.    
  
```SET```은 최대 64개를 준비한 후에 입력은 그 중에서 2개씩 세트로 데이터를 저장시키는 방식을 사용한다.  
  
### 1.1.3. 날짜와 시간 데이터 형식
```
★  DATE                             날짜 형식만 사용, 'YYYY-MM-DD'형식                   3
    TIME                             시간 형식만 사용, 'HH:MM:SS'형식                     3
★  DATETIME                         날짜와 시간 형식, 'YYYY-MM-DD HH:MM:SS'형식          8    
    TIMESTAMP                        날짜와 시간 형식(UTC), 'YYYY-MM-DD HH:MM:SS'형식     4
    YEAR                             날짜의 연도만 사용, 'YYYY'                           1
```
날짜와 시간 데이터 형식은 열 정의할때 사용 되기도 하지만    
문자열형을 변환하여 사용하는 방법도 가능하다.   
```
SELECT CAST('2020-10-19 12:35:29.123' AS DATE) AS 'DATE';
SELECT CAST('2020-10-19 12:35:29.123' AS TIME) AS 'TIME';
SELECT CAST('2020-10-19 12:35:29.123' AS DATETIME) AS 'DATETIME';
```
```CAST()```는 데이터형을 변환시켜주는 함수이다.    
위 예제에서 보이듯이 특정 형식만 맞춰주면 문자열형을 날짜/시간 데이터형으로 바꿔준다.   
    
### 1.1.3. 기타 데이터 형식
```
    GEOMETRY                         공간 데이터 형식으로 선,점 및 다각형 같은 
                                     공간 데이터 개체를 저장하고 조작 (예를 들어 지도)      N/A 
                                     
    JSON                             JSON 문서를 저장                                     8         
```
  
## 1.2. 변수의 사용
**지역 변수**
```
DECLARE 변수이름 자료형;

SET 변수명 = 값; 
또는 
SELECT 넣는 값 INTO 변수이름

SELECT 변수명 ;
```
```DECLARE 변수이름 자료형```으로 만들어진 변수는   
스토어드 프로시저나 함수 내에서만 사용 가능한 지역변수로       
무조건 **자료형 정의**를 해주어야 선언이 가능하고    
나중에 ```SET``` 이나 ```SELECT 넣는 값 INTO 변수이름``` 을 통해서 값을 대입시킨다.  
  
**전역 변수**
```
SET @변수이름 = 변수값;            -- 변수의 선언 및 값 대입
SELECT @변수이름 ;                -- 변수의 값 출력              
```
```SET @변수이름```으로 만들어진 변수는 전역변수로서  
사용하고 있는 DB(스키마)내에서 어디서든 사용 가능하다.   
   
단 정의할 때 변수만 먼저 선언하는 것은 불가능하고  
무조건 **초기화**를 진행하면서 선언을 해주어야 한다.  
그리고 자료형을 고정하지 않아서 숫자형 데이터를 입력했다가도 문자형 데이터를 넣어도 된다.  
    
```
SELECT @변수이름 + @변수이름2;
```  
그리고 이런 변수끼리의 연산도 물론 가능하며      
자료형이 다를 경우 암시적 형변환의 기준을 따른다.    
  
```LIMIT```에는 원칙적으로 변수를 사용할 수 없지만  
이를 동적할당으로 ```LIMIT```에 들어갈 값을 변수로 사용할 수도 있다.  
  
**동적할당 구조**
```
PREPARE 쿼리이름 FROM '실행할 쿼리문';          --> 쿼리문을 쿼리이름으로 저장한다고 보면 된다.

EXECUTE 쿼리이름 USING 값;                     --> 저장된 쿼리문을 쿼리이름으로 호출      
                                                   만일 쿼리문에 ? 가 있을시 ?에 값을 넣을 수 있다.
                                                   
DELLOCATE PREPARE 쿼리이름;                    --> 더이상 사용할 필요가 없으면 동적할당을 해제한다.     
```
동적할당은 말 그대로 동적으로 할당 할 수 있다는 뜻이다.   
쿼리문을 저장을 하면 언제든지 사용을 할 수 있으며 재사용도 가능하다.   
그리고 동적이라는 의미대로 언제든지 삭제할 수가 있다.  
그러니 더이상 사용하지 않는다면 동적할당 쿼리를 삭제해주자   
  
**동적할당 예시**
``` 
SET @myVar = 3;

PREPARE myQuery
    FROM 'SELECT Name, height FROM userTbl ORDER BY height LIMIT ?';

EXECUTE myQuery USING @myVar1;   

DELLOCATE PREPARE myQuery;
```
앞서 말했듯이 변수를 이용해서 ```LIMIT 값```에  접근 할 수 있다.
  
## 1.3. 데이터 형식과 형 변환
데이터 형식과 관련된 함수는 자주 사용되므로 잘 기억해 두자  
  
**데이터 형식 변환 함수**
우리는 앞서 문자열형을 날짜/시간 데이터형으로 변환하는 것을 봤다.  
  
**구조**
```
CAST( 기존 값 AS 바꿀 데이터 형식[(길이)])
CONVERT( 기존 값, 바꿀 데이터 형식[(길이)])
```
```CAST()``` 와 ```CONVERT()```는 인자 형식만 다를뿐 동작은 똑같다.   
```CAST()```는 ```AS 바꿀 데이터 형식[(길이)```
```CONVERT()```는 ```, 바꿀 데이터 형식[(길이)]```를 사용한다는 것을 기억하자.
   
**집계함수는 결과값을 문자열 형태로 반환을 한다.**  
그러기에 수치형 데이터가 필요할 경우 이를 변환해주는 작업을 해야한다.  
이럴 때 사용하는 것이 '데이터 형식 변환 함수' ```CAST()/CONVERT()```이다.
```
SELECT CAST(AVG(amount) AS SIGNED INT AS '평균 구매 개수' FROM buyTbl);

또는

SELECT CONVERT(AVG(amount), SIGNED INT AS '평균 구매 개수' FROM buyTbl);
```
일반적으로 수치형으로 변환을 할 때 무조건 ```SIGNED```를 붙여 주어야 한다.
  
## 1.4. 암시적 형 변환
형 변환에는 2가지 있다.    
하나는 명시적 형 변환으로 앞서 보았던 '데이터 형식 변환 함수'를 의미하는 것이고    
다른 하나는 암시적 형 변환으로 내부적인 동작에 의해 자동으로 형 변환이 일어나는 것을 의미한다.   
  
**원리**
```
1.  문자형(숫자값) + 문자형(숫자값)          =>     두 문자형이 정수로 반환되서 연산
2.  수치형 + 문자형(숫자값)                  =>     문자형이 정수로 반환되서 연산
3.  CONCAT(문자형(숫자값),문자형(숫자값))    =>     두 문자형이 문자형으로 결합
4.  CONCAT(수치형,문자형(숫자값))            =>     수치형이 문자형으로 바뀌며 기존 문자형과 결합
5.  1 > '2문자형'                           =>     문자형의 시작값이 2이므로 수치형 2로 간주, FALSE                  
6.  5 > '2문자형'                           =>     5번과 마찬가지로 문자형의 시작값이 2이므로 수치형 2로 간주, TRUE
7.  0 = '문자형2'                           =>     시작이 문자형이므로 0으로 간주, TRUE                   
```
어떤 DBMS는 ```SELECT '100'+'200'```의 결과가 '100200'문자열로 처리되기도 한다.     
    
***
# 2. 피벗 
## 2.1. 피버의 구현   
피벅은 한 열에 포함된 여러값을 출력하고,      
이를 여러 열로 변환하여 테이블 반환식을 회전하고 필요하면 집계까지 수행하는 일을 한다.    
만드는 방식은 ```IF()``` 함수와 ```집계함수```를 사용하는 것이다.      
  
**예시**  
``` 
SELECT uName,
    SUM(IF(seasson='봄', amount, 0)) AS '봄',
    SUM(IF(seasson='여름', amount, 0)) AS '여름',
    SUM(IF(seasson='가을', amount, 0)) AS '가을',
    SUM(IF(seasson='겨울', amount, 0)) AS '겨울',
    SUM(amount) AS '합계' FROM pivotTest GROUP BY uName; 
```
기존 테이블 구조는 이렇다.      
```uNmae``` 필드에 사용자의 이름들이 값으로 있고    
```season``` 필드에 봄, 여름, 가을, 겨울 값이 있고    
```amount``` 필드에 숫자값이 있다.   
   
```SUM()```과  ```GROUP BY uName```을 통해서 ```uName```의 값마다 그룹화 하여 합계 값을 낸다.           
```IF(season = '값', amount, 0)```을 통해 해당 되는 값이 아니면 0을 반환한다.        
해당 하는 값이 맞을 경우에는 ```SUM(amount)```가 동작된다고 보면 된다.         
그리고 이를 AS 로 알맞은 명칭으로 바꿔줘서 사용한 것이다.    
  
***
# 3. JSON
JSON은 현대의 웹과 모바일 응용프로그램 등과 데이터를 교환하기 위한 개방형 표준 포맷을 말한다.   
```속성(KEY)``` 과 ```값(VALUE)```으로 쌍을 이루며 구성되어있다.(JS에서는 이를 객체라고 말한다.)  
   
**JSON 객체**
```
{
    //키        //값
    
    "아이디" : "BBK" ,
    "이름" : "바비김" ,
    "생년" : 1973 ,
    "지역" : "서울" ,
    "국번" : "010" ,
    "전화번호" : "00000000" ,
    "키" : 178 ,
    "가입일" : "2013.5.5"
}
```
데이터베이스의 결과 집합도 이러한 JSON 객체로 변환 시킬 수 있다.   
```JSON_OBJECT()```이나 ```JSON_ARRAY()```함수를 이용하면 된다.
특히 ```JSON_OBJECT()```는 직접 JSON 객체를 생성한다는 의미가 강하다.   
**구조**
```
JSON_OBJECT('열 이름1' , 열이름1 , '열 이름2' , 열 이름2 , .....)
```
**예시**
```
SELECT JSON_OBJECT('name', name, 'height', height) AS 'JSON 값'
    FROM userTBL
     WHERE height >= 180;
     
________________________________________________________________
__________________________________
|JSON 값                         | 
|________________________________|
|{"name" : 바비김 "height" : 186}|
|________________________________|
```  
이 외에도 여러 JSON 관련 함수들이 존재한다.  
```
SET @json = '{ "userTBL" :
    [
        {"name" : "임재범", "height" : 182 },                  // &.userTBL[0]
        {"name" : "이승기", "height" : 182 },                  // &.userTBL[1]      
        {"name" : "성시경", "height" : 186 }                   // &.userTBL[2]
    ]
}' ;

SELECT JSON_VALID(@json)                                             =>     JSON 형식을 만족하면 1 아니면 0         
SELECT JSON_SEARCH(@json , 'one' , '성시경');                         =>     찾기 1개만 성시경을           
SELECT JSON_EXTRACT(@json, '$.userTBL[2].name');                     =>     name 출력
SELECT JSON_INSERT(@json, '$.userTBL[0].mDate', '2009-09-09');       =>     새로운 프로퍼티와 값 입력
SELECT JSON_REPLACE(@json, '$.userTBL[0].name', '홍길동');           =>      name을 홍길동으로 바꿈
SELECT JSON_REMOVE(@json, '$.useTBL[0]');                            =>     해당 프로퍼티 삭제                    
```
  
***
# 4. NOT IN() 과 IN()
```NOT IN()```은 첫번째 쿼리의 결과 중에서 두 번째 쿼리에 해당하는 것을 제외하기 위한 구문이다.    
간략히 말해서 첫번째 쿼리의 결과에서 ()을 제외하라는 말이다.  
```
SELECT name, CONCAT(mobile1, mobile2) AS '전화번호' FROM userTBL
    WHERE name NOT IN ( SELECT name FROM userTBL WHERE mobile1 IS NULL);
```   
위 코드를 해석하자면    
```userTBL```에서 ```mobile1```이 ```NULL``` 인 사람을 제외하고 출력하라는 말이다.   
    
반대로 IN()은 첫번째 쿼리의 결과중에서 두번째 쿼리에 행당되는 것만 조회하기 위한 구문이다.
```
SELECT name, CONCAT(mobile1, mobile2) AS '전화번호' FROM userTBL
    WHERE name IN ( SELECT name FROM userTBL WHERE mobile1 IS NULL);
```
