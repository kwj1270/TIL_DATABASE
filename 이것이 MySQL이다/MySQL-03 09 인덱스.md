인덱스
=======================
인덱스는 튜닝에 즉각적인 효과를 내는 가장 빠른 방법중에 한가지이다.  
조금더 간략하게 설명하기 위해 비유하자면 ```사전```이나 ```<찾아보기>```같은 것이다.          
     
**장점**   
* 검색 속도가 무척 빨라 질 수 있다.(단, 항상 그런것은 아니다.)  
* 그 결과 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능이 향상된다.  
  
**단점**     
* 인덱스가 DB 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 DB 크기의 10% 정도 추가로 필요하다.  
* 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다.  
* 데이터의 변경작업이 자주 일어날 경우에는 오히려 성능이 많이 나빠질 수도 있다.  
    
**튜닝**
```
SQL 서버가 기존보다 더욱 좋은 성능을 내도록 하는 전반적인 방법론이며 관점은 두가지이다.

1. 응답시간을 단축시키는 것. 
   즉, 얼마나 빨리 결과를 얻는가

2. 서버 부하량을 최소화 하는 것. 
   즉, 서버가 하는 총 작업량을 줄임으로써 시스템의 전반적인 성능을 향상시켜 서버가 더 많을 일 하도록 함
```
# 1. 인덱스의 종류와 자동 생성
## 1.1. 인덱스의 종류  
1. 클러스터형 인덱스
2. 보조 인덱스
  
**클러스터형 인덱스**
```
비유하자면 영어사전
인덱스 열에 대한 자동 정렬이 이루어지고 인덱스 자체가 책의 내용같은 것  
즉 정렬이 되어 있으며 데이터페이지 = 리프 페이지(말단 노드)인 것
테이블당 1개만 만들 수 있다.
```
**보조 인덱스**
```
비유하자면 책의 <찾아보기>
정렬이 되지 않고 오로지 순서대로만 나열되어 있으며 
데이터페이지 와 인덱스 페이지가 따로 논다.
테이블에 여러개 만들 수 있다.
```
  
## 1.2. 자동으로 생성되는 인덱스  
**클러스터형 인덱스**
```
CREATE TABLE sampleTBL(
  _id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
  str CHAR(20) NULL 
);

또는   

CREATE TABLE sampleTBL(
  _id INT UNIQUE NOT NULL,
  str CHAR(20) NULL 
);
``` 
클러스터형 인덱스는 테이블에 오직 한개만 존재해야 하므로    
```PRIMARY KEY```를 지정해주면 자동으로 생성 된다.    
    
다른 방법으로 ```UNIQUE```에 ```NOT NULL```을 붙여주면 ```PK```와 비슷한 성질을 가지니 이런 방법도 가능하다.  
```
CREATE TABLE sampleTBL(
  _id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
  str CHAR(20) UNIQUE NOT NULL
);
``` 
만약 ```UNIQUE NOT NULL``` 과 ```PK```가 겹치면 ```PK```가 우선순위이다.    
        
**보조 인덱스**
```
CREATE TABLE sampleTBL(
  no INT UNIQUE,
  str CHAR(20) NULL 
);

여러개 사용가능 

CREATE TABLE sampleTBL(
  no INT UNIQUE,
  str CHAR(20) UNIQUE 
);
```   
보조 인덱스는 테이블에 여러개 존재 가능하므로 여러개 지정 가능   
일반 ```UNQIUE``` 같은 경우는 식별은 가능하되 PK와 달리 ```NULL```도 가능하니    
보조 인덱스를 자동으로 생성해주는 키워드가 된다.    
   
**결론**
* PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다.   
* PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다.   
* UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다.  
* PK와 UNIQUE NOT NULL로 지정한 열이 동시에 있을경우 PK가 지정한 열에 클러스터형 인덱스가 생성된다.  
* UNIQUE [NULL]로 지정한 열은 보조 인덱스가 생성된다.  
  
***
# 2. 인덱스 내부 작동
## 2.1. B-TREE(균형 트리)
### 2.1.1. 내용1
```
내용1
```   
### 2.1.2. 내용1
```
내용1
```   
### 2.1.3. 클러스터형 인덱스와 보조 인덱스의 구조
```
내용1
```   
### 2.1.4. 클러스터형 인덱스와 보조 인덱스가 혼합되어 있는 구조
```
내용1
```
  
***
# 3. 인덱스 생성/변경/삭제   
자동이 아닌 수동으로 직접 인덱스를 생성하고 변경하고 삭제할 수 있다.  
## 3.1. 인덱스 생성  
**구조**
```
CREATE INDEX 인덱스명 ON 테이블명(열1, 열2, ....);  
CREATE UNIQUE INDEX 인덱스명 ON 테이블명(열1, 열2, ....);  
```
직접 인덱스를 생성하는 경우 **보조 인덱스**로 생성된다.        
보조 인덱스는 테이블에 여러개 가질 수 있고 열도 여러개 가질 수 있다.   
    
일반 보조 인덱스 생성은 값이 중복 되어도 상관이 없지만  
UNIQUE 보조 인덱스는 중복된 값이 들어올 수가 없다.  
    
```index_type {BTREE | HASH}```도 있는데 인덱스 자료구조를 설정하는 것이다.      
생략할 경우 BTREE 구조가 기본 자료구조가 된다.       
      
인덱스를 생성할 때는 그 효율성을 따져야 한다.      
예를 들어 열의 값이 작으면 굳이 인덱스를 할 필요가 없다. (이를 '선택도가 나쁜 데이터'라고 한다.)     
그러므로 인덱스를 생성할 때는 넓은 범위의 값을 가지는 필드에 지정하는 것이 좋다.  
    
## 3.2. 인덱스 삭제
```
DROP INDEX 인덱스명 ON 테이블명;
ALTER TABLE 테이블명 DROP INDEX 인덱스명;
```
인덱스를 삭제하는 것은 매우 쉽다. 단 위의 코드는 **보조 인덱스를 삭제**하는 것이다.   
클러스터형 인덱스를 삭제하고자 한다면 ```ALTER TABLE```을 사용해야한다.    
```
ALTER TABLE smapleTBL DROP PRIMARY KEY;
```
위 코드를 보면 ```PRIMARY KEY```를 아에 삭제한다.          
```PRIMARY KEY```는 클러스터형을 자동으로 생성하니 ```PK```가 존재하면 클러스터형은 삭제되지 않는다.        
만약 PK의 기능을 사용하고 싶으면 ```UNIQUE NULL```로 하되  (보조 인덱스가 생성 되겠지만...)    
데이터베이스와 연결된 프로그램에서 ```NULL```값을 보내지 않도록 하자       
      
**FK 삭제**
```
SELECT table_name , constraint_name 
  FROM information_schema.referential_constraints
  WHERE constraint_schema = 'sqlDB';
  
출력되는 테이블 참조 (constraint_name)  
    
ALTER TABLE 테이블명 DROP FOREIGN KEY 외래키의 이름(CONSTRAINT)  
ALTER TABLE smapleTBL DROP PRIMARY KEY;
```  
또한 클러스터형 인덱스를 삭제행하려는데 ```PK```를 다른 테이블에서 참조할 경우 삭제가 되지 않는다.     
이럴 경우는 위의 코드를 통해서 삭제 과정을 거치면 된다.      
    
## 3.3. 인덱스 확인
**구조**
```
SHOW INDEX FROM 테이블명;
```
현재 존재하는 인덱스의 정보를 알 수 있다.
  
**구조**
```
SHOW TABLE STATUS LIKE '테이블명';
```  
또한 인덱스의 크기를 알고자하면 위와 같이 코드를 작성하고 볼 수 있다.    
'index_length'를 보면 된다.  
  
***
# 4. 인덱스의 성능 비교
  
***
# 5. 결론
## 5.1. 인덱스는 열 단위에 생성된다.  
당연한 이야기다. 열을 기준으로 튜닝에 즉각적인 효과를 낸다.  
  
## 5.2. WHERE절에서 사용되는 열에 인덱스를 만들어야 한다.
검색을 한다는 것은 ```WHERE```를 이용한다는 것이다. 그러니 ```WHERE 절```에서 사용되는 열에 만든다.  
  
## 5.3. WHERE절에 사용되더라도 자주 사용해야 가치가 있다.   
인덱스에 지정된 열을 사용하지 않을 경우 인덱스는 실행되지 않는다.     
또한 자주 사용되지 않는다면 굳이 인덱스를 만들어 사용할 필요가 많이 없다.(공간)  
그러므로 인덱스는 테이블을 정의하는 어느 시점에 생성할 것인지를 잘 설계한 후에 지정하는 것이 바람직하다.  
    
## 5.4. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다.    
앞서 설명햇던 필드의 값이 2개라는 등 그 범위가 적다면 굳이 인덱스를 사용할 필요가 없다.     
오히려 인덱스의 관리에 대한 비용 때문에 인덱스가 없는 편이 나을 수도 있다.    
    
## 5.5. 외래키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다.    
외래키 제약 조건의 열에는 자동으로 인덱스가 생성된다.     
그리고 쿼리문에서 외래 키 인덱스가 필요할 경우, MySQL이 알아서 외래 키 인덱스를 사용하다.  
   
## 5.6. JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.    
JOIN은 ```SELECT```를 사용해서 이루어진다.    
그러므로 JOIN에 사용하는 열일 수록 인덱스를 설정하면 빠르게 값을 얻어내 결합할 수 있다      
    
JOIN외에도 **VIEW**도 ```SELECT```로 이루어진 데이터베이스 객체이므로    
VIEW에 사용되는 열에도 인덱스를 지정해주면 좋을 것 같다.    
  
## 5.7. INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해야 한다.  
인덱스는 ```SELECT```의 성능을 높이는 반면    
```INSERT/UPDATE/DELETE```의 성능을 저하시킨다.       
그렇기에 ```SELECT```이 많이 사용되는 경우도 봐야하지만    
```INSERT/UPDATE/DELETE```를 많이 사용하는 경우 신중하게 판단을 해야한다.   
     
즉, 인덱스를 만들어 '''SELEC'''T의 성능을 높일 것인지,    
인덱스를 만들지 않아서 ```INSERT/UPDATE/DELETE```시에 영향을 최소화할 것인지를 잘 결정해야 한다.    

## 5.8. 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.  
종종 클러스터형 인데스가 꼭 있어야 한다는 생각이있다.    
하지만, 클러스터형 인덱스가 없는 것이 더 나은 경우도 종종 있다.    
  
예를 들어 대용량의 데이터가 계속 입력되는 시스템이라고 가정할 때,    
데이터가 입력될 때 마다 클러스터 인덱스는 필드를 기준으로 정렬을 계속 이어나가고    
페이지 분할도 이루어 질 것이다.     
이럴 경우 시스템의 성능에 문제가 심각해질 수도 있다.    
  
그래서 이럴경우에는 클러스터 인덱스가 없는 편이 더 나을 수도 있다.  
즉 ```PK``` 대신에 ```UNIQUE NULL```을 사용한다.(대신 보조키가 생성 되었다. 필요에 따라 삭제 가능)
단, ```NULL 값```이 들어올수 있으니 응용프로그래밍 화면에서 필수로 입력 되도록 하자.(프로그래밍 언어에서)
  
**추가 예시**
```
실제로 많은 양의 사람이 한번에 회원가입을 한다고 가정시   
문제는 클러스터형 인덱스는 정렬,페이지 분할로 시간을 많이 사용하여 
시스템 성능에 심각한 문제가 발생되어 시스템이 마비되는 것과 비슷한 형상이 날 수도 있다는 것이다.
```

## 5.8. 사용하지 않는 인덱스는 제거하자
사용하지 않는 인덱스를 제거함으로써  
공간을 확보할 뿐 아니라 데이터의 입력 시에 발생되는 부하도 많이 줄일 수 있다.
