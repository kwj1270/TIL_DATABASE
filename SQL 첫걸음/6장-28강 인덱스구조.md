인덱스 구조
=======================
> 우선 정리에 앞서 아직도 개념이 명확히 잡히지는 않는다.     
> 그냥 인덱스를 만들면 읽기 속도가 빨라지고 쓰기 속도는 느려진다. 라는 개념만 있다.      
> 인덱스를 개발하는 내용이 없기에 그런것 같다.      
> 실제 다른 책을 보면 인덱스는 DB 개발자가 만들기에 아직은 개념이 뚜렷하지는 않지만 최선을 다해 정리해보겠다.      
    
```색인```이라고도 불리는 **인덱스**는 데이터베이스 객체중 하나이다.  
우선 인덱스가 무엇인지 알아보자 
  
# 1. 인덱스  
인덱스는 테이블에 붙인 **색인**이라 할 수 있다.    
인덱스의 역할은 검색속도의 향상이다. 즉 읽기(SELECT) 속도의 향상을 의미한다.    
여기서 ```검색```이란 ```SELECT```명령에 ```WHERE 구```로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정을 말한다.    
  
예를 들어보면    
책에서 본문을 처음부터 읽어나가기보다 목차나 색인을 참고해서 찾는 편이 효율적이다.    
인덱스가 바로 이러한 목차나 색인 역할을 하는 것이다.  
     
목차나 색인에 제목,키워드별 페이지번호가 적혀있듯,    
데이터베이스의 인덱스에는 검색 시에 쓰이는 키워드와 대응하는 데이터 행의 장소가 저장되어 있다.    
그리고 이들은 차례로 나열되어 있다.  
    
간단히 말하면  
```
_______        _______
|  a  |        |index|
|_____|        |_____|
|  3  |    ____|  1  |     
|_____|   |    |_____|
|  2  |   |    |  2  |     
|_____|   |    |_____|
|  4  |   |    |  3  |     
|_____|   |    |_____|
|  1  |___|    |  4  |     
|_____|        |_____|

사실 전부 연결되어있는데 그리기 힘들다;;  
```
이런식으로 연결되어 있어서 우리가 검색을 하면 index를 통해 바로 찾을 수있다.    
위의 그림으로는 데이터양이 적어 위의 말이 이해하기 어렵지만      
예를 들어 수백 수천개의 데이터가 있다고 치자 그럼 a 처럼 정리 안된 데이터에서 그중 한개를 찾겠는가?     
그럼 정리가 되면 무엇이 달라지는 것인가? 정확히 짚었다.     
자료구조에는 정렬된 데이터를 탐색하는 방법이 있다.    
인덱스는 이러한 탐색 알고리즘을 통해서 일일이 하나하나 찾는 것보다    
빠른 시간내에 데이터를 찾을 수 있게끔 해준다.    
그래서 우리는 정렬된 PK 값을 가진 인덱스를 이용하여 보다 빠르게 읽을 수 있다.    
      
인덱스는 테이블과 독립된 데이터베이스 객체로 작성된다.     
하지만 인덱스만으로는 아무런 의미가 없다.    
목차밖에 없는 책은 본 적이 없는 것처럼, 인덱스는 테이블에 의존하는 객체라 할 수 있다.    
대부분의 데이터베이스에서는 **테이블을 삭제하면 인덱스도 같이 삭제된다.**  
      
***  
# 2. 검색에 사용하는 알고리즘    
대량의 데이터를 효율적으로 검색(탐색)하는 방법은 여러가지가 있다.      
그 중 데이터베이스의 인덱스에 쓰이는 대표적인 검색 알고리즘으로는 **'이진 트리'**가 있으며    
그 다음으로는 **'해시'**가 유명하다.  
이진트리는 엄밀히 말하자면 데이터 구조이지만 이를 탐색 방법으로 말하자면 '이진 탐색이 된다'    
  
## 2.1. 풀 테이블 스캔(FULL TABLE SCAN)  
쉽게 말하면 탐색 대상을 찾을 때 까지 비교 연산을 계속한다.    
최악의 경우 마지막 인덱스까지 검색을 하는 O(n)의 결과를 낸다.    
이는 결코 좋은 탐색방법이 아니란 뜻이다.  
   
## 2.2. 이진 탐색(binary search)
이진 탐색은 우선 정렬이 되었다고 가정을 해야한다.(오름차순 정렬을 가정하겠다.)    
탐색 대상을 찾을 때까지 집합을 반으로 나누어(중간값을 구한다)    
찾고자 하는 대상이 중간값보다 크면 중간값 왼쪽에서는 더 이상 볼 필요가 없으니    
중간값의 오른쪽에서 찾는다. 물론 여기서 찾을 때도 전과 같이 집합을 반으로 나누어 비교를 한다.    
만약 중간 값이 찾는 대상이면 해당 인덱스를 얻으면 된다.    
추가로 없을 경우 앞서 말한 것처럼 반은 버리는데 이 과정을 중간값+1로 한다.    
중간 값 +1을 하는 이유는 끝까지 가서도 없을시 탈출 조건을 만들기 위해서이다.    

**가정**
```
   [0]     [1]
 ________________
|       |       |
|_______|_______|
이렇게 두개만 남았다면 중간 값+1을 안 할 경우 
계속 이상태에 머무를 것이다.

0+1/2 => 0 (나머지가 아니니)
0은 찾는 값보다 작다
+1을 안하면 다시 중간값 ~ 전체값
다시 0+1/2 -> 0 ... 무한 반복

+1을 하면 
0+1/2 => 0 (나머지가 아니니)
중간값 +1 => 1
[1] ~ [1]

ex)
___[1]___
|       |
|_______|

1+1/2 => 1  
중간값 +1 => 2  
탈출 조건 성립! 탈출합니다.  
```  
데이터가 작을 경우 이러한 탐색 결과간의 차이점을 이해하기 어렵지만    
항상 데이터는 수백 수천 수만이 있다고 가정을 해야한다.    
그럼 이진 탐색을 다시보자 절반씩 계속 자르는 것은 확실히 풀 테이블 스캔보다 낫다고 할 수 있다.    
    
그리고 다시한번 말하지만 이진 탐색은 정렬이 되어있어야 한다.  
  
## 2.2. 이진 트리(binary tree)  
일반적으로는 테이블에 인덱스를 작성하면 테이블 데이터와 별개로     
인덱스용 데이터가 저장장치에 만들어진다.    
이때 인덱스용 데이터 저장장치는 이진트리라는 데이터 구조로 작성된다.    
    
트리는 노드라는 요소로 구성되어있으며 각 노드는 두 개의 가지로 나뉘어진다.    
노드의 왼쪽 가지는(왼쪽 자식노드) 현재 노드에 비해 작은 값을    
노드의 오른쪽 가지는(오른쪽 자식노드) 현재 노드에 비해 큰 값을 가진다.  
    
이는 나중에 사진을 통해서 설명하겠다.   
간단히 말하면 이진 탐색에서 중간값들이 대표적인 트리의 자식노드(트리)가 되어 대소 비교를 해서    
값이 작으면 왼쪽으로 내려가고 값이 크면 오른쪽으로 내려간다.    

***
# 3. 유일성
이진 트리의 구조를 살피다 보면, 같은 값을 가지는 노드가 있을때는 어떻게 될까? 하는 궁금증이 생긴다.    
사실 이진 트리에서는 집합 내에 중복하는 값을 가질 수는 없다.    
즉, 노드의 가지는 큰 쪽과 작은 쪽의 두가지로 나뉘며,    
같은 값을 허용하기 위해서는 '같은'이라는 제 3의 가지(조건)를 가질 필요가 있다.  
그러면 이진 트리가 아닌 일반 트리가 되는 것이다.    
그래서 이진트리에서는 '같은 값을 가지는 노드를 여러개 만들 수 없다'라는 특성을 가지고    
이는 키에 대하여 유일성을 가지게 할 경우에만 유용하다.  

