상관 서브쿼리 
=======================
서브쿼리의 일종인 '상관 서브쿼리'를 ```EXITS```술어로 조합시켜 서브쿼리를 사용할 수 있다.
# 1. EXISTS
**EXITS** : 데이터가 존재하는지 안하는지를 판별한다.  
    
**사용 테이블**  
```
_____________
| id | a    |
|____|______|
|1   |NULL  |
|____|______|
|2   |NULL  |
|____|______|
|3   |NULL  |
|____|______|
|4   |NULL  |
|____|______|
|5   |NULL  |
|____|______|

_______
| id2 |
|_____|
|  3  |
|_____|
|  5  |
|_____|
```
**코드**
```
UPDATE mytable SET a = '있음' WHERE EXITS (SELECT * FROM sample WHERE id2 = id);
```
**결과**
```
_____________
| id | a    |
|____|______|
|1   |NULL  |
|____|______|
|2   |NULL  |
|____|______|
|3   |'있음' |
|____|______|
|4   |NULL  |
|____|______|
|5   |'있음' |
|____|______|
```
```EXITS```는 존재 유무를 판단한다.  
즉, 서브쿼리로 나온 데이터가 존재할 경우 참값을 반환한다.
간단히 말해 서브쿼리로 부터 하나의 행이 나오면 조건이 성립하여 SET구문이 동작한다.
  
그리고 서브쿼리도 깊게 보면 상위 쿼리의 필드를 사용하고 있다.  
서브쿼리는 자신을 호출한 쿼리의 열도 사용할 수 있다.  

***
# 2. NOT EXITS
```NOT EXITS```는 ```EXITS```와 반대로 데이터가 없을시 참값을 반환한다.
그래서 위에 코드를 조금 더 작성해보자 

**코드**
```
UPDATE mytable SET a = '없음' WHERE NOT EXITS (SELECT * FROM sample WHERE id2 = id);
```
**결과**
```
_____________
| id | a    |
|____|______|
|1   |'없음  |
|____|______|
|2   |'없음  |
|____|______|
|3   |'있음' |
|____|______|
|4   |'없음  |
|____|______|
|5   |'있음' |
|____|______|
```

***
# 3. 상관 서브쿼리
UPDATE (부모 명령)에서 서브쿼리는 자신을 호출한 쿼리(부모 명령)의 필드를 사용하여 값을 갱신했다.   
이렇듯 부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 '상관 서브쿼리'라 부른다.  

상관 서브쿼리에서는 부모 명령과 연관되어 처리되기 때문에  
서브쿼리 부분만을 따로 떼어서 실행시킬 수 없다.
```
UPDATE mytable SET a = '있음' WHERE EXITS (SELECT * FROM sample WHERE id2 = id)

SELECT * FROM sample WHERE id2 = id;      ->    X
```
즉 부모와 연관되어 있는 서브쿼리를 '상관 서브쿼리'라 말한다.  

# 3.1. 테이블명 붙이기
앞서 '상관 서브쿼리'를 살펴 보았다.   
만약  ```UPDATE mytable SET a = '있음' WHERE EXITS (SELECT * FROM sample WHERE id2 = id);```에서  
```id2``` 와 ```id```가 아닌 ```id```와 ```id```일 경우는 어떻게 될까?  
물론 ERROR가 발생한다 왜냐하면 어떤 것을 기준으로 삼아야 할지 모르기 때문이다.   
그래서 이를 명확히 하고자 테이블 명을 붙일 수 있다.   
  
**예시**
```
UPDATE mytable SET a = '있음' 
    WHERE EXITS (SELECT * FROM sample WHERE sample.id = mytable.id);```
```

***
# 4. IN()
스칼라 값은 값이 하나이므로 ```=```을 사용했다.   
그렇다면 만약 값이 여러개인 집합일 경우는? 그때 사용하는 것이 ```IN()```이다.  
   
```IN()```은 OR 조건식을 의미하는 것으로 
```
WHEN 열 IN(값1 , 값2 ,...);
```
이런식으로 자주 사용된다.  
앞서 '있음', '없음'이 나누어진 테이블에 
```
SELECT * FROM mytable WHERE id IN (3,5);
``` 
이런식으로 코드를 작성하면   
  
**결과**
```
_____________
| id | a    |
|____|______|
|3   |'있음' |
|____|______|
|5   |'있음' |
|____|______|
```
이유는 간단하다 3 또는 5를 제한으로 걸었으니 이렇게 출력된다.  
또한 이를 서브쿼리로도 나타낼 수 있다.  
```
SELECT * FROM mytable 
  WHERE id IN (SELECT no2 FROM sample);
```
**결과**
```
_____________
| id | a    |
|____|______|
|3   |'있음' |
|____|______|
|5   |'있음' |
|____|______|
```
no2는 3,5 값을 가지니 똑같은 결과가 나온다.

## 4.1. NOT IN()
```IN()```의 반대인 ```NOT IN()```도 존재한다.  
정확히 말하자면 아무 값이 없을 경우 참이 된다.(하나라도 값이 있으면 FALSE)  

## 4.2. IN() 과 NULL
집계 함수에서는 ```NULL값```을 무시했지만  
```IN()```에서는 ```NULL 값```을 무시하지 않는다.  
다만 ```IN```을 사용해도 ```NULL 값```은 비교할 수 없다.  
즉 ```NULL값```을 비교하고 싶으면 ```IS NULL```을 사용하자  
또한 ```NOT IN```의 경우 ```NULL 값```이 있으면 ```UNKNOWN```이 된다.  

